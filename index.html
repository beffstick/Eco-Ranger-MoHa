<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eco Ranger: Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #e0f2fe;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0 auto;
            /* Default responsive behavior */
            max-width: 100%; 
            background: linear-gradient(180deg, #bae6fd 0%, #f0f9ff 100%);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: max-width 0.3s;
        }

        /* Mode 1 Player: Limit width on large screens for better UX */
        #game-container.single-player {
            max-width: 600px; 
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
        }

        /* Mode 2 Player: Full width */
        #game-container.two-player {
            max-width: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            z-index: 20;
            transition: opacity 0.3s;
            padding: 20px;
            overflow-y: auto;
        }

        .hidden {
            display: none !important;
        }

        /* Buttons */
        .btn {
            width: 100%;
            max-width: 300px;
            margin: 6px 0;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, filter 0.2s;
            text-align: center;
            border: 3px solid rgba(0,0,0,0.1);
            position: relative;
            white-space: nowrap;
        }

        .btn:active { transform: scale(0.98); }
        .btn-primary { background: #0ea5e9; color: white; border-bottom: 5px solid #0284c7; }
        .btn-success { background: #22c55e; color: white; border-bottom: 5px solid #15803d; }
        .btn-warning { background: #f59e0b; color: white; border-bottom: 5px solid #b45309; }
        .btn-danger { background: #ef4444; color: white; border-bottom: 5px solid #b91c1c; }
        .btn-purple { background: #8b5cf6; color: white; border-bottom: 5px solid #6d28d9; }

        .btn.selected {
            border: 3px solid #000;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }

        /* HUD - Split Logic */
        .hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 10;
        }

        .hud-panel {
            position: absolute;
            top: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 8px;
            border: 2px solid #333;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        /* Player 1 HUD (Left/Single) */
        .p1-hud.score { left: 10px; color: #16a34a; }
        .p1-hud.stat { right: 10px; color: #ef4444; } /* Default single player pos */
        .p1-hud.center { left: 50%; transform: translateX(-50%); top: 50px; font-size: 0.8rem; }

        /* Player 2 HUD (Right - only visible in 2P) */
        .p2-hud { display: none; }
        .two-player-mode .p1-hud.stat { right: 52%; } /* Shift P1 stat to near center-left */
        .two-player-mode .p2-hud { display: block; }
        .two-player-mode .p2-hud.score { left: 52%; color: #16a34a; }
        .two-player-mode .p2-hud.stat { right: 10px; color: #ef4444; }

        .card {
            background: white; border-radius: 12px; padding: 15px; margin-bottom: 10px;
            border: 2px solid #eee; width: 100%; max-width: 400px;
            display: flex; align-items: center; gap: 15px;
        }
        .logo-img { height: 80px; margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="game-container" class="single-player">
        <!-- HUD Layer -->
        <div id="hud-layer" class="hud-layer">
            <!-- P1 HUD -->
            <div id="p1-score" class="hud-panel p1-hud score">P1 Skor: 0</div>
            <div id="p1-stat" class="hud-panel p1-hud stat">‚è≥ 60</div>
            <div id="p1-level" class="hud-panel p1-hud center">Lv.1</div>

            <!-- P2 HUD -->
            <div id="p2-score" class="hud-panel p2-hud score">P2 Skor: 0</div>
            <div id="p2-stat" class="hud-panel p2-hud stat">‚è≥ 60</div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <!-- 1. MAIN MENU -->
        <div id="menu-screen" class="ui-overlay">
            <img src="assets/logo.png" alt="Logo" class="logo-img" onerror="this.src='https://via.placeholder.com/150?text=Eco+Ranger'">
            <h1 class="text-4xl font-bold text-slate-800 mb-2">Eco Ranger</h1>
            <p class="text-sm text-slate-500 mb-6 font-bold">EDUKASI PILAH SAMPAH</p>
            
            <button onclick="showScreen('setup-screen')" class="btn btn-primary">üéÆ Mulai Main</button>
            <button onclick="showScreen('tutorial-screen')" class="btn btn-warning">üìñ Cara Bermain</button>
            <button onclick="showScreen('materi-screen')" class="btn btn-success">üìö Materi Sampah</button>
        </div>

        <!-- 2. SETUP SCREEN -->
        <div id="setup-screen" class="ui-overlay hidden">
            <h2 class="text-xl font-bold text-slate-700 mb-2">Setup Permainan</h2>
            
            <!-- Players Select -->
            <div class="w-full max-w-sm mb-3">
                <p class="text-xs font-bold text-slate-400 mb-1">Jumlah Pemain:</p>
                <div class="flex gap-2">
                    <button id="pl-1" onclick="selectPlayers(1)" class="btn btn-primary flex-1 py-2 text-sm selected">üë§ 1 Player</button>
                    <button id="pl-2" onclick="selectPlayers(2)" class="btn btn-purple flex-1 py-2 text-sm">üë• 2 Players</button>
                </div>
                <p id="p2-warning" class="hidden text-xs text-red-500 text-center mt-1 font-bold">‚ö†Ô∏è Mode 2 Player memerlukan layar lebar (Tablet/TV).</p>
            </div>

            <!-- Mode Toggle -->
            <div class="w-full max-w-sm mb-3">
                <p class="text-xs font-bold text-slate-400 mb-1">Mode:</p>
                <div class="flex gap-2">
                    <button id="mode-time" onclick="selectMode('time')" class="btn btn-primary flex-1 py-2 text-sm selected">Time Attack</button>
                    <button id="mode-endless" onclick="selectMode('endless')" class="btn btn-primary flex-1 py-2 text-sm">Endless</button>
                </div>
            </div>

            <!-- Level Select -->
            <div class="w-full max-w-sm mb-3">
                <p class="text-xs font-bold text-slate-400 mb-1">Kesulitan:</p>
                <div class="flex flex-col gap-1">
                    <button id="lvl-1" onclick="selectLevel(1)" class="btn btn-success py-1 text-sm selected">üå± Pemula</button>
                    <button id="lvl-2" onclick="selectLevel(2)" class="btn btn-warning py-1 text-sm">üõ°Ô∏è Penjaga</button>
                    <button id="lvl-3" onclick="selectLevel(3)" class="btn btn-danger py-1 text-sm">‚öîÔ∏è Eco Ranger</button>
                </div>
            </div>

            <!-- Duration (Time Mode Only) -->
            <div id="duration-selector" class="w-full max-w-sm mb-4">
                <p class="text-xs font-bold text-slate-400 mb-1">Durasi:</p>
                <div class="flex gap-2">
                    <button id="dur-1" onclick="selectDuration(1)" class="btn btn-primary py-1 text-sm selected">1 Min</button>
                    <button id="dur-2" onclick="selectDuration(2)" class="btn btn-primary py-1 text-sm">2 Min</button>
                    <button id="dur-3" onclick="selectDuration(3)" class="btn btn-primary py-1 text-sm">3 Min</button>
                </div>
            </div>

            <div class="flex gap-2 w-full max-w-sm mt-2">
                <button onclick="showScreen('menu-screen')" class="btn bg-slate-400 text-white">Kembali</button>
                <button onclick="startGame()" class="btn btn-success">Mulai! ‚ñ∂</button>
            </div>
        </div>

        <!-- 3. TUTORIAL -->
        <div id="tutorial-screen" class="ui-overlay hidden">
            <h2 class="text-2xl font-bold text-slate-800 mb-4">Cara Bermain</h2>
            <img src="assets/tangan.png" class="w-16 mb-4 animate-bounce" onerror="this.style.display='none'">
            <ul class="text-left list-disc pl-6 space-y-2 text-slate-700 max-w-sm text-sm">
                <li>Sampah jatuh dari atas.</li>
                <li><strong>Drag & Drop</strong> sampah ke tong yang benar.</li>
                <li><strong>Mode 2 Player:</strong> Layar terbagi dua. Pemain 1 kiri, Pemain 2 kanan. Jangan lewati garis batas!</li>
                <li><span class="text-green-600 font-bold">Benar +10</span>, <span class="text-red-500 font-bold">Salah -5</span>, <span class="text-orange-500 font-bold">Lewat -3</span>.</li>
            </ul>
            <button onclick="showScreen('menu-screen')" class="btn btn-primary mt-8">Kembali</button>
        </div>

        <!-- 4. MATERI -->
        <div id="materi-screen" class="ui-overlay hidden">
            <h2 class="text-2xl font-bold text-slate-800 mb-4">Jenis Sampah</h2>
            <div class="card border-green-200 bg-green-50">
                <div class="text-3xl">üçé</div>
                <div><h3 class="font-bold text-green-700">Organik</h3><p class="text-xs">Mudah membusuk (Sisa makanan, daun).</p></div>
            </div>
            <div class="card border-yellow-200 bg-yellow-50">
                <div class="text-3xl">ü•§</div>
                <div><h3 class="font-bold text-yellow-700">Anorganik</h3><p class="text-xs">Sulit terurai (Plastik, kertas, kaleng).</p></div>
            </div>
            <div class="card border-red-200 bg-red-50">
                <div class="text-3xl">üîã</div>
                <div><h3 class="font-bold text-red-700">B3 / Berbahaya</h3><p class="text-xs">Beracun (Baterai, obat, kimia).</p></div>
            </div>
            <button onclick="showScreen('menu-screen')" class="btn btn-primary mt-4">Kembali</button>
        </div>

        <!-- 5. GAME OVER -->
        <div id="game-over-screen" class="ui-overlay hidden">
            <h1 id="go-title" class="text-3xl font-bold text-slate-800 mb-2">Selesai!</h1>
            
            <!-- Result Container -->
            <div id="go-results" class="flex flex-col gap-4 mb-6 w-full max-w-md">
                <!-- Injected via JS -->
            </div>

            <button onclick="showScreen('setup-screen')" class="btn btn-primary">Main Lagi ‚Ü∫</button>
            <button onclick="showScreen('menu-screen')" class="btn btn-warning">Menu Utama üè†</button>
        </div>
    </div>

    <script>
        // --- KONFIGURASI ---
        const assetConfig = {
            background: 'assets/background.jpg', 
            logo: 'assets/logo.png',
            hand: 'assets/tangan.png',
            feedback: { correct: 'assets/benar.png', wrong: 'assets/salah.png' },
            audio: { correct: 'assets/benar.ogg', wrong: 'assets/salah.ogg', bgm: 'assets/bgmusic.ogg' },
            bins: {
                organik: { idle: 'assets/organik_1.png', active: 'assets/organik_2.png', color: '#4ade80' },
                anorganik: { idle: 'assets/anorganik_1.png', active: 'assets/anorganik_2.png', color: '#facc15' },
                berbahaya: { idle: 'assets/berbahaya_1.png', active: 'assets/berbahaya_2.png', color: '#ef4444' }
            }
        };

        // --- GLOBAL VARS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        
        // Game Settings
        let gameConfig = {
            players: 1, // 1 or 2
            mode: 'time',
            level: 1,
            duration: 1
        };

        let players = []; // Array of GameInstance
        let isPlaying = false;
        let gameLoopId;
        
        // --- PRELOAD ASSETS ---
        const loadedImages = {};
        const loadedAudio = {};
        const trashData = { organik: [], anorganik: [], berbahaya: [] };

        function preloadImage(key, src) { const i = new Image(); i.src = src; loadedImages[key] = i; }
        function preloadAudio(key, src, loop) { const a = new Audio(src); a.loop = loop; loadedAudio[key] = a; }

        preloadImage('hand', assetConfig.hand);
        preloadImage('correct', assetConfig.feedback.correct);
        preloadImage('wrong', assetConfig.feedback.wrong);
        Object.keys(assetConfig.bins).forEach(k => {
            preloadImage(`bin_${k}_idle`, assetConfig.bins[k].idle);
            preloadImage(`bin_${k}_active`, assetConfig.bins[k].active);
        });
        preloadAudio('correct', assetConfig.audio.correct, false);
        preloadAudio('wrong', assetConfig.audio.wrong, false);
        preloadAudio('bgm', assetConfig.audio.bgm, true);

        ['organik', 'anorganik', 'berbahaya'].forEach(type => {
            for(let i=1; i<=10; i++) {
                let k = `${type}_${i}`;
                trashData[type].push(k);
                preloadImage(k, `assets/sampah_${type}_${i}.png`);
            }
        });

        // --- GAME INSTANCE CLASS (Untuk Multi-Player) ---
        class GameInstance {
            constructor(id, xOffset, width, height) {
                this.id = id; // 0 or 1
                this.xOffset = xOffset;
                this.width = width;
                this.height = height;
                
                // State
                this.score = 0;
                this.lives = 5;
                this.isGameOver = false;
                this.consecutiveCorrect = 0;
                
                // Time Mode State
                this.startTime = Date.now();
                this.endTime = this.startTime + (gameConfig.duration * 60000);
                
                // Endless State
                this.endlessStartTime = Date.now();
                this.currentLevel = gameConfig.level;

                // Objects
                this.trashes = [];
                this.feedbackEffects = [];
                this.bins = [];
                this.activeDrags = {}; // Map touchId -> {item, dx, dy}
                
                // Mechanics
                this.lastSpawnTime = 0;
                this.spawnRate = 2000;
                this.baseSpeed = 2;
                
                this.setupBins();
                this.setDifficulty(this.currentLevel);
            }

            setDifficulty(lvl) {
                if (lvl === 1) { this.spawnRate = 2500; this.baseSpeed = 1.5; }
                else if (lvl === 2) { this.spawnRate = 1500; this.baseSpeed = 2.5; }
                else { this.spawnRate = 800; this.baseSpeed = 4.0 + ((lvl-3)*0.5); }
            }

            setupBins() {
                this.bins = [];
                let pad = 10;
                let w = (this.width - pad*4)/3;
                this.bins.push(new Bin('organik', 'Organik', '#4ade80', pad, w));
                this.bins.push(new Bin('anorganik', 'Anorganik', '#facc15', pad*2+w, w));
                this.bins.push(new Bin('berbahaya', 'Berbahaya', '#ef4444', pad*3+w*2, w));
            }

            spawnTrash(timestamp) {
                if (this.isGameOver) return;
                
                // Endless Level Up
                if (gameConfig.mode === 'endless') {
                    let elapsedSec = Math.floor((Date.now() - this.endlessStartTime) / 1000);
                    let calcLevel = Math.floor(elapsedSec / 60) + gameConfig.level;
                    if (calcLevel > this.currentLevel) {
                        this.currentLevel = calcLevel;
                        this.setDifficulty(this.currentLevel);
                        this.spawnFeedback('correct', "LEVEL UP!");
                    }
                }

                if (timestamp - this.lastSpawnTime > this.spawnRate) {
                    this.trashes.push(new Trash(this.width, this.baseSpeed, this.score));
                    this.lastSpawnTime = timestamp;
                }
            }

            update(timestamp) {
                if (this.isGameOver) return;

                // Time Check
                if (gameConfig.mode === 'time') {
                    let remaining = Math.max(0, this.endTime - Date.now());
                    if (remaining <= 0) this.isGameOver = true;
                } else if (this.lives <= 0) {
                    this.isGameOver = true;
                }

                this.spawnTrash(timestamp);

                // Update Trashes
                for (let i = this.trashes.length - 1; i >= 0; i--) {
                    let t = this.trashes[i];
                    // Handle Drag Movement here
                    if (t.draggingBy !== null) {
                        // Position handled by input event, just rotate logic here if needed
                    } else {
                        t.update();
                    }

                    // Missed logic
                    if (t.y > this.height + 50) {
                        this.trashes.splice(i, 1);
                        this.handleResult('miss');
                    }
                }

                // Update Effects
                for (let i = this.feedbackEffects.length - 1; i >= 0; i--) {
                    let fx = this.feedbackEffects[i];
                    fx.update();
                    if (fx.life <= 0) this.feedbackEffects.splice(i, 1);
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.xOffset, 0);

                // Draw Separator Border if 2P
                if (gameConfig.players === 2) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0); ctx.lineTo(0, this.height);
                    ctx.stroke();
                }

                // Draw Bins
                this.bins.forEach(b => b.draw(ctx, this.height));

                // Draw Trashes
                this.trashes.forEach(t => t.draw(ctx));

                // Draw Effects
                this.feedbackEffects.forEach(f => f.draw(ctx));

                // Game Over Overlay specific to player area
                if (this.isGameOver) {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(0, 0, this.width, this.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 30px Fredoka';
                    ctx.textAlign = 'center';
                    ctx.fillText("SELESAI", this.width/2, this.height/2);
                    ctx.font = '20px Fredoka';
                    ctx.fillText(`Skor: ${this.score}`, this.width/2, this.height/2 + 40);
                }

                ctx.restore();
            }

            handleResult(res) {
                if (this.isGameOver) return;
                
                if (res === 'correct') {
                    this.score += 10;
                    if (gameConfig.mode === 'endless') {
                        this.consecutiveCorrect++;
                        if (this.consecutiveCorrect >= 5) {
                            this.lives++; this.consecutiveCorrect = 0;
                            this.spawnFeedback('correct', "+1 ‚ù§Ô∏è");
                        } else {
                            this.spawnFeedback('correct', "+10");
                        }
                    } else {
                        this.spawnFeedback('correct', "+10");
                    }
                } else if (res === 'wrong') {
                    this.consecutiveCorrect = 0;
                    if (gameConfig.mode === 'time') {
                        this.score -= 5;
                        this.spawnFeedback('wrong', "-5");
                    } else {
                        this.lives--;
                        this.spawnFeedback('wrong', "üíî");
                    }
                } else if (res === 'miss') {
                     this.consecutiveCorrect = 0;
                     if (gameConfig.mode === 'time') {
                        this.score -= 3;
                        this.spawnFeedback('wrong', "-3");
                    } else {
                        this.lives--;
                        this.spawnFeedback('wrong', "üíî");
                    }
                }
            }

            spawnFeedback(type, text) {
                this.feedbackEffects.push(new FeedbackEffect(this.width, this.height, type, text));
                let aud = loadedAudio[type];
                if(aud) { aud.currentTime=0; aud.play().catch(()=>{}); }
            }

            // Input Handlers
            inputStart(id, localX, y) {
                if (this.isGameOver) return;
                // Find top trash under point
                for (let i = this.trashes.length - 1; i >= 0; i--) {
                    let t = this.trashes[i];
                    if (t.draggingBy !== null) continue; // Already dragged
                    let dist = Math.sqrt((localX - t.x)**2 + (y - t.y)**2);
                    if (dist < 50) {
                        t.draggingBy = id;
                        this.activeDrags[id] = t;
                        return;
                    }
                }
            }

            inputMove(id, localX, y) {
                let t = this.activeDrags[id];
                if (t) {
                    t.x = localX; t.y = y;
                }
            }

            inputEnd(id) {
                let t = this.activeDrags[id];
                if (t) {
                    t.draggingBy = null;
                    delete this.activeDrags[id];
                    
                    // Check collision
                    let hit = false;
                    for (let b of this.bins) {
                        if (t.x > b.x && t.x < b.x+b.width && t.y > b.y && t.y < b.y+b.height) {
                            hit = true;
                            if (t.type === b.type) this.handleResult('correct');
                            else this.handleResult('wrong');
                            break;
                        }
                    }

                    if (hit) {
                        let idx = this.trashes.indexOf(t);
                        if (idx > -1) this.trashes.splice(idx, 1);
                    }
                }
            }
        }

        // --- SUB CLASSES ---
        class Bin {
            constructor(type, label, color, x, width) {
                this.type = type; this.label = label; this.fallbackColor = color;
                this.x = x; this.width = width; this.height = 0;
            }
            draw(ctx, parentHeight) {
                this.height = Math.min(this.width * 1.2, 130);
                this.y = parentHeight - this.height - 20;
                
                let k = `bin_${this.type}_idle`; // Simplify, no hover visual for now
                let img = loadedImages[k];
                if(img && img.complete) ctx.drawImage(img, this.x, this.y, this.width, this.height);
                else {
                    ctx.fillStyle = this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Trash {
            constructor(maxWidth, speedBase, scoreMod) {
                let types = Object.keys(trashData);
                this.type = types[Math.floor(Math.random()*types.length)];
                let arr = trashData[this.type];
                this.key = arr[Math.floor(Math.random()*arr.length)];
                
                this.size = 50;
                this.x = Math.random() * (maxWidth - this.size*2) + this.size;
                this.y = -60;
                this.speed = speedBase + (Math.random()*0.5);
                this.angle = Math.random() * 6.28;
                this.spin = (Math.random()-0.5)*0.1;
                this.draggingBy = null;
            }
            update() { this.y += this.speed; this.angle += this.spin; }
            draw(ctx) {
                let img = loadedImages[this.key];
                ctx.save();
                ctx.translate(this.x, this.y);
                if(this.draggingBy !== null) {
                    let hand = loadedImages['hand'];
                    if(hand && hand.complete) ctx.drawImage(hand, -50, -50, 100, 100);
                    ctx.globalAlpha = 0.7;
                }
                ctx.rotate(this.angle);
                if(img && img.complete) ctx.drawImage(img, -this.size/2, -this.size/2, this.size, this.size);
                else {
                    ctx.beginPath(); ctx.arc(0,0,this.size/2,0,6.28);
                    ctx.fillStyle = this.type==='organik'?'green':(this.type==='anorganik'?'yellow':'red');
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class FeedbackEffect {
            constructor(w, h, type, text) {
                this.x = Math.random()*(w-100)+50;
                this.y = Math.random()*(h-200)+100;
                this.type = type; this.text = text; this.life=1.0; this.scale=0.5;
            }
            update() { this.life-=0.02; this.y-=1; if(this.scale<1.0) this.scale+=0.05; }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                let img = loadedImages[this.type];
                if(img && img.complete) {
                    let s = 80*this.scale;
                    ctx.drawImage(img, this.x-s/2, this.y-s/2, s, s);
                }
                if(this.text) {
                    ctx.fillStyle = this.type==='correct'?'#16a34a':'#ef4444';
                    ctx.font = "bold 24px Fredoka"; ctx.textAlign="center";
                    ctx.shadowColor="white"; ctx.shadowBlur=4;
                    ctx.fillText(this.text, this.x, this.y+50);
                }
                ctx.restore();
            }
        }

        // --- CORE FUNCTIONS ---

        function showScreen(id) {
            document.querySelectorAll('.ui-overlay').forEach(el => el.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function selectPlayers(n) {
            gameConfig.players = n;
            document.getElementById('pl-1').classList.toggle('selected', n===1);
            document.getElementById('pl-2').classList.toggle('selected', n===2);
            if(n===2) document.getElementById('p2-warning').classList.remove('hidden');
            else document.getElementById('p2-warning').classList.add('hidden');
        }

        function selectMode(m) {
            gameConfig.mode = m;
            document.getElementById('mode-time').classList.toggle('selected', m==='time');
            document.getElementById('mode-endless').classList.toggle('selected', m==='endless');
            document.getElementById('duration-selector').style.display = m==='time'?'block':'none';
        }
        function selectLevel(l) { gameConfig.level=l; [1,2,3].forEach(i=>document.getElementById(`lvl-${i}`).classList.toggle('selected',i===l)); }
        function selectDuration(d) { gameConfig.duration=d; [1,2,3].forEach(i=>document.getElementById(`dur-${i}`).classList.toggle('selected',i===d)); }

        function resizeGame() {
            // Apply class for CSS
            if (gameConfig.players === 2) {
                container.classList.remove('single-player');
                container.classList.add('two-player');
                document.getElementById('hud-layer').classList.add('two-player-mode');
            } else {
                container.classList.add('single-player');
                container.classList.remove('two-player');
                document.getElementById('hud-layer').classList.remove('two-player-mode');
            }
            // Canvas resize
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Re-setup bins for existing players if running
            if (isPlaying) {
                let w = canvas.width / gameConfig.players;
                players.forEach(p => {
                    p.width = w;
                    p.height = canvas.height;
                    p.xOffset = p.id * w;
                    p.setupBins();
                });
            }
        }

        function startGame() {
            resizeGame();
            showScreen('game-container');
            document.querySelectorAll('.ui-overlay').forEach(e=>e.classList.add('hidden'));

            players = [];
            let w = canvas.width / gameConfig.players;
            for(let i=0; i<gameConfig.players; i++) {
                players.push(new GameInstance(i, i*w, w, canvas.height));
            }

            isPlaying = true;
            
            let bgm = loadedAudio['bgm'];
            if(bgm) { bgm.currentTime=0; bgm.play().catch(()=>{}); }

            if(gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if(!isPlaying) return;

            ctx.clearRect(0,0,canvas.width, canvas.height);

            let allOver = true;
            players.forEach(p => {
                p.update(timestamp);
                p.draw(ctx);
                if(!p.isGameOver) allOver = false;
            });
            
            updateHUD();

            if (allOver) {
                setTimeout(endGame, 1000);
                return;
            }

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updateHUD() {
            // P1
            document.getElementById('p1-score').innerText = `P1 Skor: ${players[0].score}`;
            if(gameConfig.mode==='time') {
                 let rem = Math.max(0, players[0].endTime - Date.now());
                 document.getElementById('p1-stat').innerText = `‚è≥ ${Math.ceil(rem/1000)}`;
            } else {
                 document.getElementById('p1-stat').innerText = `‚ù§Ô∏è ${players[0].lives}`;
                 document.getElementById('p1-level').innerText = `Lv.${players[0].currentLevel}`;
            }

            // P2
            if (players[1]) {
                document.getElementById('p2-score').innerText = `P2 Skor: ${players[1].score}`;
                if(gameConfig.mode==='time') {
                     let rem = Math.max(0, players[1].endTime - Date.now());
                     document.getElementById('p2-stat').innerText = `‚è≥ ${Math.ceil(rem/1000)}`;
                } else {
                     document.getElementById('p2-stat').innerText = `‚ù§Ô∏è ${players[1].lives}`;
                }
            }
        }

        function endGame() {
            isPlaying = false;
            let bgm = loadedAudio['bgm'];
            if(bgm) bgm.pause();

            let resHtml = "";
            if (gameConfig.players === 1) {
                resHtml = `<div class="bg-blue-100 p-4 rounded-lg text-center">
                    <p class="text-lg font-bold">Skor Kamu</p>
                    <p class="text-4xl font-bold text-green-600">${players[0].score}</p>
                </div>`;
            } else {
                let p1 = players[0].score;
                let p2 = players[1].score;
                let winText = p1 > p2 ? "üèÜ Pemain 1 Menang!" : (p2 > p1 ? "üèÜ Pemain 2 Menang!" : "ü§ù Seri!");
                resHtml = `
                <h3 class="text-2xl font-bold text-center text-purple-600 mb-2">${winText}</h3>
                <div class="flex gap-4 w-full">
                    <div class="flex-1 bg-blue-100 p-4 rounded-lg text-center">
                        <p class="font-bold">Pemain 1</p>
                        <p class="text-3xl text-green-600">${p1}</p>
                    </div>
                    <div class="flex-1 bg-purple-100 p-4 rounded-lg text-center">
                        <p class="font-bold">Pemain 2</p>
                        <p class="text-3xl text-green-600">${p2}</p>
                    </div>
                </div>`;
            }

            document.getElementById('go-results').innerHTML = resHtml;
            showScreen('game-over-screen');
        }

        // --- INPUT HANDLING (Multitouch Support) ---
        function handleInput(e, type) {
            if(!isPlaying) return;
            e.preventDefault();
            
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [{identifier: 'mouse', clientX: e.clientX, clientY: e.clientY}];
            const rect = canvas.getBoundingClientRect();

            touches.forEach(t => {
                let gx = t.clientX - rect.left;
                let gy = t.clientY - rect.top;
                
                // Determine Player based on X
                let pIdx = 0;
                let pWidth = canvas.width / gameConfig.players;
                if (gameConfig.players === 2 && gx > pWidth) pIdx = 1;

                let localX = gx - (pIdx * pWidth);
                let player = players[pIdx];

                if (type === 'start') player.inputStart(t.identifier, localX, gy);
                else if (type === 'move') player.inputMove(t.identifier, localX, gy);
                else if (type === 'end') player.inputEnd(t.identifier);
            });
        }

        // Listeners
        canvas.addEventListener('mousedown', e => handleInput(e, 'start'));
        canvas.addEventListener('mousemove', e => handleInput(e, 'move'));
        window.addEventListener('mouseup', e => handleInput(e, 'end'));
        
        canvas.addEventListener('touchstart', e => handleInput(e, 'start'), {passive:false});
        canvas.addEventListener('touchmove', e => handleInput(e, 'move'), {passive:false});
        window.addEventListener('touchend', e => handleInput(e, 'end'));
        
        window.addEventListener('resize', () => {
             // Debounce resize
             clearTimeout(window.resizeTimer);
             window.resizeTimer = setTimeout(resizeGame, 100);
        });

        // Init
        document.getElementById('game-container').style.backgroundImage = `url('${assetConfig.background}')`;
        showScreen('menu-screen');

    </script>
</body>
</html>
